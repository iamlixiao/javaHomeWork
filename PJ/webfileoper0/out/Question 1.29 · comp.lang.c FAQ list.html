<!DOCTYPE HTML PUBLIC "-//W3O//DTD W3 HTML 2.0//EN"><!-- This collection of hypertext pages is Copyright 1995-2005 by Steve Summit. --><!-- Content from the book "C Programming FAQs: Frequently Asked Questions" --><!-- (Addison-Wesley, 1995, ISBN 0-201-84519-9) is made available here by --><!-- permission of the author and the publisher as a service to the community. --><!-- It is intended to complement the use of the published text --><!-- and is protected by international copyright laws. --><!-- The on-line content may be accessed freely for personal use --><!-- but may not be published or retransmitted without explicit permission. --><!-- --><!-- this page built Sat Dec 24 21:47:45 2005 by faqproc version 2.7 --><!-- from source file decl.sgml dated Wed Dec 21 12:56:18 2005 --><!-- corresponding to FAQ list version 4.0 --><html><head><meta name=GENERATOR content="faqproc"><title>Question 1.29</title><link href="bigdatastr.html" rev=precedes><link href="initval.html" rel=precedes><link href="index.html" rev=subdocument></head><body bgcolor="#ffffff"><p><!-- qbegin --><p><font face=Helvetica size=8 color=blue><b>Q:</b></font>How can I determinewhich identifiers are safe for me to useand which are reserved?</p><p><hr><p><font face=Helvetica size=8 color=blue><b>A:</b></font>Namespace management can be a sticky issue.The problem--which isn't alwaysobvious--is that you don't wantto pick identifiers already in use by the implementation,such thatyouget``multiply defined'' errorsor--even worse--quietlyreplaceone of the implementation's symbolsandbreakeverything.You also want some guarantee that later releaseswon't usurp namesyou're legitimately using.<a href="internal.html" rel=subdocument>[footnote]</a>(Few things are more frustratingthan taking a debugged, working, production program,recompiling it under a new release of a compiler,and having the build faildue to namespace or other problems.)Therefore,the ANSI/ISO C Standard contains rather elaborate definitionscarving out distinct namespace subsetsfor the user and the implementation.</p><p>To make sense of ANSI's rules,andbefore we can say whether a given identifier is reserved,we must understand three attributes ofthe identifier:its scope, namespace, and linkage.</p><p>There are four kinds of scope(regions over which anidentifier's declaration is in effect)in C:function,file,block,andprototype.(The fourthoneexists only in the parameter listsof function prototype declarations;see also question <a href="../ansi/structinproto.html">11.5</a>.)</p><p>There are four different kinds of namespaces,for:<UL><li>labels(i.e. <TT>goto</TT> targets);<li>tags(names of structures, unions,andenumerations;thesethreearen't separate even though they theoretically could be);<li>structure/union members(one namespace per structure or union);and<li>everything else(functions, variables, typedef names, enumeration constants),termed ``ordinary identifiers'' by the Standard.</UL></p><p>Another set of names(though not termed a ``namespace'' by the Standard)consists of preprocessor macros;these are all expandedbefore the compiler gets around to considering the four formal namespaces.</p><p>The standard defines three kinds of ``linkage'':external, internal, and none.For our purposes,external linkage means global,non-<TT>static</TT> variables and functions(across all source files),internal linkage means <TT>static</TT> variables and functionswith file scope,and``no linkage''refers to local variables,and also things like typedef names and enumeration constants.</p><p>The rules,paraphrased fromANSI Sec. 4.1.2.1,are:</p><UL><li>1.Allidentifiers beginning with an underscorefollowed by an upper-case letter or another underscoreare always reserved(all scopes, all namespaces).<li>2.Allidentifiers beginning with an underscoreare reserved for ordinary identifiers(functions, variables, typedefs, enumeration constants)with file scope.<li>3.Amacro name defined in a standard headeris reserved for any useifanyheader which <TT>#define</TT>s it is <TT>#include</TT>d.<li>4.Allstandard library identifierswith external linkage(e.g. function names)are always reservedas identifiers with external linkage.<li>5.Typedefandtag names,with file scope,defined in standard headers,are reserved at file scope(in the same namespace)if the corresponding header is <TT>#include</TT>d.(The Standard really says``each identifier with file scope,''but the only standard identifiers not covered by rule 4are typedef and tag names.)</UL><p>Rules 3 and 4are additionally complicated by the fact thatseveral sets of macro names and standard library identifiersare reserved for ``future directions''that is,later revisions of the Standardmay define new names matching certain patterns.</p><p>Here is a list of the patterns which are reserved for ``future directions''associared with each standard header:<blockquote>[TABLE GOES HERE]</blockquote>(The notation <TT>[A-Z]</TT> means ``any uppercase letter'';similarly, <TT>[a-z]</TT> and <TT>[0-9]</TT> indicate lower-case letters and digits.The notation <TT>*</TT> means ``anything.''For example,the pattern for <TT>&lt;stdlib.h&gt;</TT> says thatall external identifiers beginning with the letters <TT>str</TT>followed by a lower-case letterare reserved.)</p><p>What do theaboverules really mean?If you want to be on the safe side:</p><UL><li>1,2.Don'tgive anything a namewith a leading underscore.<li>3.Don'tgive anything a namewhich is already astandard macro(including the ``future directions'' patterns).<li>4.Don'tgiveany functions or global variablesnameswhich are already taken byfunctions or variables in the standard library,orwhich matchany of the ``future directions'' patterns.(Strictly speaking, ``matching'' meansmatching in the first six characters,without regard to case;see question <a href="../ansi/extidsignif.html">11.27</a>.)<li>5.Don't redefine standard typedefor tag names.</UL><p>In fact,the precedingsubparagraphsare overly conservative.If you wish,you mayremember the following exceptions:</p><UL><li>1,2.You may use identifiers consisting ofan underscorefollowed by a digit or lower case letterfor labels and structure/union members.<li>1,2.You may use identifiers consisting ofan underscorefollowed by a digit or lower case letterat function, block, or prototype scope.<li>3.You may use names matching standard macro namesif you don't <TT>#include</TT> any header files which <TT>#define</TT> them.<li>4.You may use names of standard library routines as static or local variables(strictly speaking, as identifiers with internal or no linkage).<li>5.You may use standard typedef and tag namesif you don't <TT>#include</TT> any header files which declare them.</UL><p>However,before making use of any of these exceptions,recognize thatsome of them are pretty risky(especially exceptions 3 and 5,sinceyou couldaccidentally <TT>#include</TT> the relevant header fileat a later time,perhaps through a chain of nested <TT>#include</TT> files),and others(especially the ones labeled 1,2)represent sort of a ``no man's land''between the user namespacesand the namespaces reserved to the implementation.</p><p>One reason for providing these exceptionsis to allow the implementorsof various add-in librariesa way to declaretheir owninternal or``hidden'' identifiers.If you make use of any of the exceptions,you won't clash with any identifiers defined by the Standard,but you might clash with somethingdefined by a third-party library you're using.(If,on the other hand,you'rethe one who'simplementing an add-on library,you're welcome to make use of them,if necessary,and if you're careful.)</p><p>(It <em>is</em>generally safe to make use of exception 4to give function parametersor local variablesnames matching standard library routinesor ``future directions'' patterns.For example,``<TT>string</TT>''is acommon--and legal--namefor aparameter or local variable.)</p><p>Additional links:<a href="http://www.concentric.net/~Brownsta/c-predef.htm">Stan Brown's comprehensive list of reserved identifiers</a></p><p>References:ISO Sec. 6.1.2.1, Sec. 6.1.2.2, Sec. 6.1.2.3, Sec. 7.1.3, Sec. 7.13<br>Rationale Sec. 4.1.2.1<br>H&amp;S Sec. 2.5 pp. 21-3, Sec. 4.2.1 p. 67, Sec. 4.2.4 pp. 69-70, Sec. 4.2.7 p. 78, Sec. 10.1 p. 284<br></p><!-- aend --><p><hr>